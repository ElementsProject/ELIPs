<pre>
  ELIP: ????
  Layer: Wallet
  Title: CT Descriptors for Elements
  Author: Andrew Poelstra <apoelstra@blockstream.com>
          Tim Ruffing <crypto@timruffing.de>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/ElementsProject/elips/wiki/Comments:ELIP-????
  Status: Draft
  Type: Standards Track
  Created: 2022-10-06
  License: BSD-3-Clause
</pre>

==Introduction==

===Abstract===

This document proposes a new wrapper around existing and future Elements descriptor types, which allows attaching a confidential blinding key to an ordinary output script descriptor. It introduces new syntax to support both existing SLIP77-style confidential keys as well as a new, more flexible style.

===Copyright===

This document is licensed under the 3-clause BSD license.

===Motivation===

Confidential Transactions involve the use of uniformly random "blinding factors" associated to every confidential output.
These random values are secret, but must be known by the sender (in order to construct a transaction) as well as recipient (in order to recognize the received assets and amounts, and to spend the outputs).
This means they must be chosen by the sender of a transaction and somehow securely communicated to the recipient.

The way this is done is that confidential addresses contain the public key of an extra "blinding key" pair created by the recipient.
When blinding, the sender chooses a fresh EC Diffie-Hellman (ECDH) private key, encodes the corresponding public key in the "nonce" field of the transaction, derives an ECDH secret between the fresh private key and the public blinding key, uses the ECDH secret to encrypt the blinding factors for the output, and encodes the encrypted result in the rangeproof.
The recipient, when recognizing a scriptPubKey corresponding to the ordinary part of her confidential address, uses the private blinding key for that address in conjunction with the nonce field of the txout to re-derive the ECDH secret and decrypt the blinding factors.

This document defines a standard way for the recipient's wallet to compute blinding key pairs. There are a number of requirements:

* Confidential addresses, including their attached blinding key, should be derivable from a single descriptor without extra data
* Wallets should be able to choose the granularity of their blinding keys, so that the revelation of private blinding keys may unblind one, a subset, or all, of its blinded outputs
* In multiparty settings, each wallet should be able to restrict this granularity
* It should be possible somehow to do public derivation of CT addresses, given only a descriptor containing (extended) public keys

The current most popular scheme, [https://github.com/satoshilabs/slips/blob/master/slip-0077.md SLIP-77], does not satisfy any of these criteria, which limits its usefulness as we move toward a descriptor-centric setting in which multiparty addresses are common.

==Design==

===Overview===
We propose a new <code>ct</code> descriptor which wraps any other descriptor type in the form <code>ct(<BLINDING_KEY>, <DESCRIPTOR>)</code>.
Here <code>DESCRIPTOR</code> refers to any existing descriptor, e.g. <code>elwsh(...)</code> or <code>eltr(...)</code> and <code>BLINDING_KEY</code> is a new expression which must be one of
* <code>slip77(<64-character hex>)</code> which indicates that blinding keys for these addresses are derived via SLIP77; or
* <code>hash_to_private(<KEY_1>, <KEY_2>, ...)</code> which indicates that the blinding key is produced by a hash of the sorted list of one or more public keys; or
* <code><KEY></code> which is an ordinary (extended) public key which will be used as a blinding key

In both the <code>hash_to_private</code> and <code><KEY></code> expressions, all keys must be compressed; x-only and uncompressed keys are invalid.

We note that even if the descriptor includes private keys, as it will when used for wallet backups, the keys included in the <code>hash_to_private</code> combinator will be converted to public keys before sorting and hashing.

We further note that even single-party wallets are likely to use the <code>hash_to_private()</code> adaptor rather than directly using <code><key></code>.
The reason is that decrypting rangeproofs requires the private key corresponding to <code><key></code>, which likely means that decryption happens on a hardware wallet.
Since decryption is as computationally complex as verifying a rangeproof, we do not expect common wallets to support it directly.
This form of descriptor may become more common post-Bulletproofs, when we will make decryption much easier.

===Drawbacks===

Our scheme uses derived "public" keys (i.e., EC points) to compute private blinding keys, because
* Many hardware wallets are incapable of producing rangeproofs, which require significant memory and processing power, but they will not reveal private keys to the host computer, only public keys;
* Public keys alone cannot be used for multiparty addresses, since we require that each individual participant be able to unblind confidential outputs sent to a multiparty address.

However, this has the following drawbacks:
* The mismatch between "public" keys being used in a "secret" context may lead to user confusion; though we argue this is no worse than the "secret" chaincode value being included in xpubs used by Bitcoin wallets.
* Any party who has a copy of an addresses' descriptor is able to see the blinding key and unblind coins sent to that address, or *any* derived address in the case of a non-derived descriptor (one containing wildcards).

===Specification===

First, the <code>ct</code> descriptor is defined as above: its string serialization is given by <code>ct(<BLINDING_KEY>, <DESCRIPTOR>)</code> where <code>DESCRIPTOR</code> is the string serialization of an ordinary descriptor.
The <code>scriptPubKey</code> corresponding to a <code>ct</code> descriptor is that corresponding to the embedded <code>DESCRIPTOR</code>. The encoding and semantics of <code>BLINDING_KEY</code> are given below.

<code>BLINDING_KEY</code> expressions are one of
* '''slip77''', encoded as <code>slip77(<64-characters hex>)</code>, whose semantics are that the 64 hex characters are interpreted as the 32-byte <code>master_blinding_key</code> in SLIP77; the <code>scriptPubKey</code> for SLIP77 is computed as normal from the ordinary descriptor.
These 32 bytes are the same for both public and private descriptors; they have no "public" equivalent.
This mode is not recommended because there is no way to express this descriptor without revealing the SLIP77 key, which can be used to unblind every single output received by the wallet.
* '''hash_to_private''' takes a list of public or private keys, encoded identically to the keys in the <code>ordinary descriptor</code>. The semantics are to use a [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design BIP-340 tagged hash] with tag <code>CT-Blinding-Key/1.0</code> to hash the following data:
** the <code>scriptPubKey</code> of the output, consensus-encoded including its length prefix; followed by
** every public key, in 33-byte compressed encoding, concatenated in lexicographic order The output of this hash, when interpreted as an integer (most significant byte first) modulo the group order, is the blinding ''private'' key. If this hash is zero, the resulting descriptor is invalid.
* '''bare key''', which simply encodes a single key in the same way as the keys in <code>ordinary descriptor</code> are encoded.
This may be a private or public key; its public key is used as the blinding key for the address. 

==Security==

==Backwards Compatibility==

Using the <code>ct(slip77(<64-byte hex>), <DESCRIPTOR>)</code> construction, any wallet should be able to express its existing confidential addresses using this new scheme.

==Acknowledgements==

We would like to thank Leo Comandini for describing practical requirements by wallet authors, and to Jonas Nick for providing feedback on the cryptographic design.

